{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-scene.min.js","webpack:///webpack/bootstrap c48df86790a1ddb58c33","webpack:///./index.js","webpack:///./ReactScene.jsx","webpack:///external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack:///./createScene.jsx","webpack:///../~/hoist-non-react-statics/index.js","webpack:///./withScene.jsx"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","ReactScene","createScene","withScene","React","createClass","displayName","propTypes","width","PropTypes","number","height","loadOnMount","bool","buildOnLoad","playOnBuild","destroyOnUnmount","load","func","build","resize","mute","unmute","play","pause","end","destroy","onRemote","sceneWillLoad","sceneDidLoad","sceneWillBuild","sceneDidBuild","sceneWillResize","sceneDidResize","sceneWillMute","sceneDidMute","sceneWillUnmute","sceneDidUnmute","sceneWillPlay","sceneDidPlay","sceneWillPause","sceneDidPause","sceneWillEnd","sceneDidEnd","childContextTypes","scene","object","contextTypes","getChildContext","parent","context","getDefaultProps","getInitialState","calling","render","props","children","componentDidMount","remote","createRemote","componentWillUnmount","componentDidUpdate","prevProps","prevState","onRemoteChanged","sizeChanged","callSceneMethod","arguments","name","args","state","setState","pascalName","substr","toUpperCase","methodName","willLoadName","didLoadName","done","_","bind","isAsync","obj","async","methodArgs","concat","map","arg","methodReturn","apply","then","promiseDone","getDisplayName","WrappedComponent","_extends","Object","assign","target","i","length","source","key","prototype","hasOwnProperty","hoistStatics","SceneWithContext","cloneElement","SceneWrapper","method","methods","methodProps","ml","refs","component","createElement","ref","REACT_STATICS","defaultProps","mixins","type","KNOWN_STATICS","caller","arity","isGetOwnPropertySymbolsAvailable","getOwnPropertySymbols","targetComponent","sourceComponent","customStatics","keys","getOwnPropertyNames","error","WithScene"],"mappings":"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","file":"react-scene.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScene\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactScene\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScene\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactScene\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar ReactScene = __webpack_require__(1);\n\tReactScene.createScene = __webpack_require__(3);\n\tReactScene.withScene = __webpack_require__(5);\n\t\n\tmodule.exports = ReactScene;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar ReactScene = React.createClass({\n\t    displayName: 'ReactScene',\n\t\n\t\n\t    propTypes: {\n\t\n\t        width: React.PropTypes.number,\n\t        height: React.PropTypes.number,\n\t\n\t        loadOnMount: React.PropTypes.bool,\n\t        buildOnLoad: React.PropTypes.bool,\n\t        playOnBuild: React.PropTypes.bool,\n\t        destroyOnUnmount: React.PropTypes.bool,\n\t\n\t        load: React.PropTypes.func,\n\t        build: React.PropTypes.func,\n\t        resize: React.PropTypes.func,\n\t        mute: React.PropTypes.func,\n\t        unmute: React.PropTypes.func,\n\t        play: React.PropTypes.func,\n\t        pause: React.PropTypes.func,\n\t        end: React.PropTypes.func,\n\t        destroy: React.PropTypes.func,\n\t\n\t        onRemote: React.PropTypes.func,\n\t\n\t        //Scene lifecycle\n\t        sceneWillLoad: React.PropTypes.func,\n\t        sceneDidLoad: React.PropTypes.func,\n\t        sceneWillBuild: React.PropTypes.func,\n\t        sceneDidBuild: React.PropTypes.func,\n\t        sceneWillResize: React.PropTypes.func,\n\t        sceneDidResize: React.PropTypes.func,\n\t        sceneWillMute: React.PropTypes.func,\n\t        sceneDidMute: React.PropTypes.func,\n\t        sceneWillUnmute: React.PropTypes.func,\n\t        sceneDidUnmute: React.PropTypes.func,\n\t        sceneWillPlay: React.PropTypes.func,\n\t        sceneDidPlay: React.PropTypes.func,\n\t        sceneWillPause: React.PropTypes.func,\n\t        sceneDidPause: React.PropTypes.func,\n\t        sceneWillEnd: React.PropTypes.func,\n\t        sceneDidEnd: React.PropTypes.func\n\t\n\t    },\n\t\n\t    childContextTypes: {\n\t        scene: React.PropTypes.object\n\t    },\n\t\n\t    contextTypes: {\n\t        scene: React.PropTypes.object\n\t    },\n\t\n\t    getChildContext: function getChildContext() {\n\t        return {\n\t            scene: {\n\t                parent: this.context.scene || null,\n\t                load: this.load,\n\t                build: this.build,\n\t                resize: this.resize,\n\t                mute: this.mute,\n\t                unmute: this.unmute,\n\t                play: this.play,\n\t                pause: this.pause,\n\t                end: this.end,\n\t                destroy: this.destroy\n\t            }\n\t        };\n\t    },\n\t\n\t    getDefaultProps: function getDefaultProps() {\n\t        return {\n\t            width: 0,\n\t            height: 0,\n\t\n\t            loadOnMount: true,\n\t            buildOnLoad: false,\n\t            playOnBuild: false,\n\t            destroyOnUnmount: true\n\t        };\n\t    },\n\t\n\t    getInitialState: function getInitialState() {\n\t        return {\n\t            calling: null\n\t        };\n\t    },\n\t\n\t    render: function render() {\n\t        return this.props.children || null;\n\t    },\n\t\n\t    componentDidMount: function componentDidMount() {\n\t        if (this.props.onRemote) {\n\t            var remote = this.createRemote();\n\t            this.props.onRemote(remote);\n\t        }\n\t\n\t        if (this.props.loadOnMount) {\n\t            this.load();\n\t        }\n\t    },\n\t\n\t    componentWillUnmount: function componentWillUnmount() {\n\t        if (this.props.destroyOnUnmount) {\n\t            this.destroy();\n\t        }\n\t    },\n\t\n\t    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t        var onRemoteChanged = prevProps.onRemote !== this.props.onRemote;\n\t        if (onRemoteChanged && this.props.onRemote) {\n\t            var remote = this.createRemote();\n\t            this.props.onRemote(remote);\n\t        }\n\t\n\t        var sizeChanged = prevProps.width !== this.props.width || prevProps.height !== this.props.height;\n\t        if (sizeChanged) {\n\t            this.resize();\n\t        }\n\t    },\n\t\n\t    load: function load() {\n\t        this.callSceneMethod('load', arguments);\n\t    },\n\t\n\t    build: function build() {\n\t        this.callSceneMethod('build', arguments);\n\t    },\n\t\n\t    resize: function resize() {\n\t        this.callSceneMethod('resize', arguments);\n\t    },\n\t\n\t    mute: function mute() {\n\t        this.callSceneMethod('mute', arguments);\n\t    },\n\t\n\t    unmute: function unmute() {\n\t        this.callSceneMethod('unmute', arguments);\n\t    },\n\t\n\t    play: function play() {\n\t        this.callSceneMethod('play', arguments);\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.callSceneMethod('pause', arguments);\n\t    },\n\t\n\t    end: function end() {\n\t        this.callSceneMethod('end', arguments);\n\t    },\n\t\n\t    destroy: function destroy() {\n\t        this.callSceneMethod('destroy', arguments);\n\t    },\n\t\n\t    callSceneMethod: function callSceneMethod(name, args) {\n\t        if (this.state.calling === name) {\n\t            return;\n\t        }\n\t\n\t        this.setState({\n\t            calling: name\n\t        });\n\t\n\t        var pascalName = name.substr(0, 1).toUpperCase() + name.substr(1);\n\t        var methodName = name;\n\t        var willLoadName = 'sceneWill' + pascalName;\n\t        var didLoadName = 'sceneDid' + pascalName;\n\t\n\t        var done = _.bind(function () {\n\t            this.setState({\n\t                calling: null\n\t            });\n\t\n\t            //Call the \"did\" lifecycle method\n\t            if (this.props[didLoadName]) {\n\t                this.props[didLoadName]();\n\t            }\n\t\n\t            if (this[didLoadName]) {\n\t                this[didLoadName]();\n\t            }\n\t        }, this);\n\t\n\t        var isAsync = false;\n\t        var obj = {\n\t            async: function async() {\n\t                isAsync = true;\n\t                return done;\n\t            }\n\t        };\n\t\n\t        //Calling \"will\" lifecycle method\n\t        if (this.props[willLoadName]) {\n\t            this.props[willLoadName]();\n\t        }\n\t\n\t        //Calling method\n\t        if (this.props[methodName]) {\n\t            var methodArgs = [obj].concat(_.map(args, function (arg) {\n\t                return arg;\n\t            }));\n\t            var methodReturn = this.props[methodName].apply(null, methodArgs);\n\t            if (methodReturn && methodReturn.then) {\n\t                var promiseDone = obj.async();\n\t                methodReturn.then(promiseDone);\n\t            }\n\t        }\n\t\n\t        //If the call is not async, it's done\n\t        if (!isAsync) {\n\t            done();\n\t        }\n\t    },\n\t\n\t    createRemote: function createRemote() {\n\t        return {\n\t            load: this.load,\n\t            build: this.build,\n\t            resize: this.resize,\n\t            mute: this.mute,\n\t            unmute: this.unmute,\n\t            play: this.play,\n\t            pause: this.pause,\n\t            end: this.end,\n\t            destroy: this.destroy\n\t        };\n\t    },\n\t\n\t    /**\n\t     * Scene lifecycle\n\t     */\n\t    sceneDidLoad: function sceneDidLoad() {\n\t        if (this.props.buildOnLoad) {\n\t            this.build();\n\t        }\n\t    },\n\t\n\t    sceneDidBuild: function sceneDidBuild() {\n\t        if (this.props.playOnBuild) {\n\t            this.play();\n\t        }\n\t    }\n\t\n\t});\n\t\n\tmodule.exports = ReactScene;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar ReactScene = __webpack_require__(1);\n\tvar hoistStatics = __webpack_require__(4);\n\t\n\tfunction getDisplayName(WrappedComponent) {\n\t    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\t}\n\t\n\tmodule.exports = function (WrappedComponent, props) {\n\t    var SceneWithContext = React.createClass({\n\t        displayName: 'SceneWithContext',\n\t\n\t\n\t        contextTypes: {\n\t            scene: React.PropTypes.object\n\t        },\n\t\n\t        render: function render() {\n\t            var children = React.cloneElement(this.props.children, {\n\t                scene: this.context.scene\n\t            });\n\t\n\t            return children;\n\t        }\n\t\n\t    });\n\t\n\t    var SceneWrapper = React.createClass({\n\t        displayName: 'SceneWrapper',\n\t\n\t\n\t        render: function render() {\n\t            var methods = ['load', 'build', 'resize', 'mute', 'unmute', 'play', 'pause', 'end', 'destroy'];\n\t            var methodProps = {};\n\t            var method;\n\t            for (var i = 0, ml = methods.length; i < ml; i++) {\n\t                method = methods[i];\n\t                if (this.refs.component && this.refs.component[method]) {\n\t                    methodProps[method] = this.refs.component[method];\n\t                }\n\t            }\n\t\n\t            return React.createElement(\n\t                ReactScene,\n\t                _extends({\n\t                    ref: 'scene'\n\t                }, this.props, props, methodProps),\n\t                React.createElement(\n\t                    SceneWithContext,\n\t                    null,\n\t                    React.createElement(WrappedComponent, _extends({ ref: 'component' }, this.props))\n\t                )\n\t            );\n\t        },\n\t\n\t        load: function load() {\n\t            this.refs.scene.load();\n\t        },\n\t\n\t        build: function build() {\n\t            this.refs.scene.build();\n\t        },\n\t\n\t        resize: function resize() {\n\t            this.refs.scene.resize();\n\t        },\n\t\n\t        mute: function mute() {\n\t            this.refs.scene.mute();\n\t        },\n\t\n\t        unmute: function unmute() {\n\t            this.refs.scene.unmute();\n\t        },\n\t\n\t        play: function play() {\n\t            this.refs.scene.play();\n\t        },\n\t\n\t        pause: function pause() {\n\t            this.refs.scene.pause();\n\t        },\n\t\n\t        end: function end() {\n\t            this.refs.scene.end();\n\t        },\n\t\n\t        destroy: function destroy() {\n\t            this.refs.scene.destroy();\n\t        }\n\t\n\t    });\n\t\n\t    SceneWrapper.displayName = 'scene(' + getDisplayName(WrappedComponent) + ')';\n\t    SceneWrapper.WrappedComponent = WrappedComponent;\n\t\n\t    return hoistStatics(SceneWrapper, WrappedComponent);\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t    name: true,\n\t    length: true,\n\t    prototype: true,\n\t    caller: true,\n\t    arguments: true,\n\t    arity: true\n\t};\n\t\n\tvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\t\n\tmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t        var keys = Object.getOwnPropertyNames(sourceComponent);\n\t\n\t        /* istanbul ignore else */\n\t        if (isGetOwnPropertySymbolsAvailable) {\n\t            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n\t                try {\n\t                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n\t                } catch (error) {\n\t\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return targetComponent;\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar ReactScene = __webpack_require__(1);\n\tvar hoistStatics = __webpack_require__(4);\n\t\n\tfunction getDisplayName(WrappedComponent) {\n\t    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\t}\n\t\n\tmodule.exports = function (WrappedComponent) {\n\t    var WithScene = React.createClass({\n\t        displayName: 'WithScene',\n\t\n\t\n\t        contextTypes: {\n\t            scene: React.PropTypes.object\n\t        },\n\t\n\t        render: function render() {\n\t            return React.createElement(WrappedComponent, _extends({}, this.props, { scene: this.context.scene }));\n\t        }\n\t\n\t    });\n\t\n\t    WithScene.displayName = 'withScene(' + getDisplayName(WrappedComponent) + ')';\n\t    WithScene.WrappedComponent = WrappedComponent;\n\t\n\t    return hoistStatics(WithScene, WrappedComponent);\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-scene.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c48df86790a1ddb58c33\n **/","var ReactScene = require('./ReactScene');\nReactScene.createScene = require('./createScene');\nReactScene.withScene = require('./withScene');\n\nmodule.exports = ReactScene;\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","var React = require('react');\n\nvar ReactScene = React.createClass({\n    \n    propTypes: {\n        \n        width: React.PropTypes.number,\n        height: React.PropTypes.number,\n        \n        loadOnMount: React.PropTypes.bool,\n        buildOnLoad: React.PropTypes.bool,\n        playOnBuild: React.PropTypes.bool,\n        destroyOnUnmount: React.PropTypes.bool,\n        \n        load: React.PropTypes.func,\n        build: React.PropTypes.func,\n        resize: React.PropTypes.func,\n        mute: React.PropTypes.func,\n        unmute: React.PropTypes.func,\n        play: React.PropTypes.func,\n        pause: React.PropTypes.func,\n        end: React.PropTypes.func,\n        destroy: React.PropTypes.func,\n        \n        onRemote: React.PropTypes.func,\n        \n        //Scene lifecycle\n        sceneWillLoad: React.PropTypes.func,\n        sceneDidLoad: React.PropTypes.func,\n        sceneWillBuild: React.PropTypes.func,\n        sceneDidBuild: React.PropTypes.func,\n        sceneWillResize: React.PropTypes.func,\n        sceneDidResize: React.PropTypes.func,\n        sceneWillMute: React.PropTypes.func,\n        sceneDidMute: React.PropTypes.func,\n        sceneWillUnmute: React.PropTypes.func,\n        sceneDidUnmute: React.PropTypes.func,\n        sceneWillPlay: React.PropTypes.func,\n        sceneDidPlay: React.PropTypes.func,\n        sceneWillPause: React.PropTypes.func,\n        sceneDidPause: React.PropTypes.func,\n        sceneWillEnd: React.PropTypes.func,\n        sceneDidEnd: React.PropTypes.func\n        \n    },\n    \n    childContextTypes: {\n        scene: React.PropTypes.object\n    },\n    \n    contextTypes: {\n        scene: React.PropTypes.object\n    },\n    \n    getChildContext: function()\n    {\n        return {\n            scene: {\n                parent: this.context.scene || null,\n                load: this.load,\n                build: this.build,\n                resize: this.resize,\n                mute: this.mute,\n                unmute: this.unmute,\n                play: this.play,\n                pause: this.pause,\n                end: this.end,\n                destroy: this.destroy\n            }\n        };\n    },\n    \n    getDefaultProps: function()\n    {\n        return {\n            width: 0,\n            height: 0,\n            \n            loadOnMount: true,\n            buildOnLoad: false,\n            playOnBuild: false,\n            destroyOnUnmount: true\n        };\n    },\n    \n    getInitialState: function()\n    {\n        return {\n            calling: null\n        };\n    },\n    \n    render: function()\n    {\n        return this.props.children || null;\n    },\n    \n    componentDidMount: function()\n    {\n        if(this.props.onRemote)\n        {\n            var remote = this.createRemote();\n            this.props.onRemote(remote);\n        }\n        \n        if(this.props.loadOnMount)\n        {\n            this.load();\n        }\n    },\n    \n    componentWillUnmount: function()\n    {\n        if(this.props.destroyOnUnmount)\n        {\n            this.destroy();\n        }\n    },\n    \n    componentDidUpdate: function(prevProps, prevState)\n    {\n        var onRemoteChanged = prevProps.onRemote !== this.props.onRemote;\n        if(onRemoteChanged && this.props.onRemote)\n        {\n            var remote = this.createRemote();\n            this.props.onRemote(remote);\n        }\n        \n        var sizeChanged = prevProps.width !== this.props.width || prevProps.height !== this.props.height;\n        if(sizeChanged)\n        {\n            this.resize();\n        }\n    },\n    \n    load: function()\n    {\n        this.callSceneMethod('load', arguments);\n    },\n    \n    build: function()\n    {\n        this.callSceneMethod('build', arguments);\n    },\n    \n    resize: function()\n    {\n        this.callSceneMethod('resize', arguments);\n    },\n    \n    mute: function()\n    {\n        this.callSceneMethod('mute', arguments);\n    },\n    \n    unmute: function()\n    {\n        this.callSceneMethod('unmute', arguments);\n    },\n    \n    play: function()\n    {\n        this.callSceneMethod('play', arguments);\n    },\n    \n    pause: function()\n    {\n        this.callSceneMethod('pause', arguments);\n    },\n    \n    end: function()\n    {\n        this.callSceneMethod('end', arguments);\n    },\n    \n    destroy: function()\n    {\n        this.callSceneMethod('destroy', arguments);\n    },\n    \n    callSceneMethod: function(name, args)\n    {\n        if(this.state.calling === name)\n        {\n            return;\n        }\n        \n        this.setState({\n            calling: name\n        });\n        \n        var pascalName = name.substr(0, 1).toUpperCase()+name.substr(1);\n        var methodName = name;\n        var willLoadName = 'sceneWill'+pascalName;\n        var didLoadName = 'sceneDid'+pascalName;\n        \n        var done = _.bind(function()\n        {\n            this.setState({\n                calling: null\n            });\n            \n            //Call the \"did\" lifecycle method\n            if(this.props[didLoadName])\n            {\n                this.props[didLoadName]();\n            }\n            \n            if(this[didLoadName])\n            {\n                this[didLoadName]();\n            }\n            \n        }, this);\n        \n        var isAsync = false;\n        var obj = {\n            async: function()\n            {\n                isAsync = true;\n                return done;\n            }\n        };\n        \n        //Calling \"will\" lifecycle method\n        if(this.props[willLoadName])\n        {\n            this.props[willLoadName]();\n        }\n        \n        //Calling method\n        if(this.props[methodName])\n        {\n            var methodArgs = [obj].concat(_.map(args, function(arg)\n            {\n                return arg;\n            }));\n            var methodReturn = this.props[methodName].apply(null, methodArgs);\n            if(methodReturn && methodReturn.then)\n            {\n                var promiseDone = obj.async();\n                methodReturn.then(promiseDone);\n            }\n        }\n        \n        //If the call is not async, it's done\n        if(!isAsync)\n        {\n            done();\n        }\n    },\n    \n    createRemote: function()\n    {\n        return {\n            load: this.load,\n            build: this.build,\n            resize: this.resize,\n            mute: this.mute,\n            unmute: this.unmute,\n            play: this.play,\n            pause: this.pause,\n            end: this.end,\n            destroy: this.destroy\n        };\n    },\n    \n    /**\n     * Scene lifecycle\n     */\n    sceneDidLoad: function()\n    {\n        if(this.props.buildOnLoad)\n        {\n            this.build();\n        }\n    },\n    \n    sceneDidBuild: function()\n    {\n        if(this.props.playOnBuild)\n        {\n            this.play();\n        }\n    }\n    \n});\n\nmodule.exports = ReactScene;\n\n\n\n/** WEBPACK FOOTER **\n ** ./ReactScene.jsx\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}\n ** module id = 2\n ** module chunks = 0\n **/","var ReactScene = require('./ReactScene');\nvar hoistStatics = require('hoist-non-react-statics');\n\nfunction getDisplayName(WrappedComponent)\n{\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nmodule.exports = function(WrappedComponent, props)\n{\n    var SceneWithContext = React.createClass({\n        \n        contextTypes: {\n            scene: React.PropTypes.object\n        },\n        \n        render: function()\n        {\n            var children = React.cloneElement(this.props.children, {\n                scene: this.context.scene\n            });\n            \n            return children;\n        }\n        \n    });\n    \n    var SceneWrapper = React.createClass({\n        \n        render: function()\n        {\n            var methods = ['load', 'build', 'resize', 'mute', 'unmute', 'play', 'pause', 'end', 'destroy'];\n            var methodProps = {};\n            var method;\n            for(var i = 0, ml = methods.length; i < ml; i++)\n            {\n                method = methods[i];\n                if(this.refs.component && this.refs.component[method])\n                {\n                    methodProps[method] = this.refs.component[method];\n                }\n            }\n            \n            return (\n                <ReactScene\n                    ref=\"scene\"\n                    {...this.props}\n                    {...props}\n                    {...methodProps}\n                    >\n                    <SceneWithContext>\n                        <WrappedComponent ref=\"component\" {...this.props} />\n                    </SceneWithContext>\n                </ReactScene>\n            );\n        },\n        \n        load: function()\n        {\n            this.refs.scene.load();\n        },\n        \n        build: function()\n        {\n            this.refs.scene.build();\n        },\n        \n        resize: function()\n        {\n            this.refs.scene.resize();\n        },\n        \n        mute: function()\n        {\n            this.refs.scene.mute();\n        },\n        \n        unmute: function()\n        {\n            this.refs.scene.unmute();\n        },\n        \n        play: function()\n        {\n            this.refs.scene.play();\n        },\n        \n        pause: function()\n        {\n            this.refs.scene.pause();\n        },\n        \n        end: function()\n        {\n            this.refs.scene.end();\n        },\n        \n        destroy: function()\n        {\n            this.refs.scene.destroy();\n        }\n        \n    });\n    \n    SceneWrapper.displayName = `scene(${getDisplayName(WrappedComponent)})`;\n    SceneWrapper.WrappedComponent = WrappedComponent;\n    \n    return hoistStatics(SceneWrapper, WrappedComponent);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./createScene.jsx\n **/","/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/hoist-non-react-statics/index.js\n ** module id = 4\n ** module chunks = 0\n **/","var ReactScene = require('./ReactScene');\nvar hoistStatics = require('hoist-non-react-statics');\n\nfunction getDisplayName(WrappedComponent)\n{\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nmodule.exports = function(WrappedComponent)\n{\n    var WithScene = React.createClass({\n        \n        contextTypes: {\n            scene: React.PropTypes.object\n        },\n        \n        render: function()\n        {\n            return (\n                <WrappedComponent {...this.props} scene={this.context.scene} />\n            );\n        }\n        \n    });\n    \n    WithScene.displayName = `withScene(${getDisplayName(WrappedComponent)})`;\n    WithScene.WrappedComponent = WrappedComponent;\n    \n    return hoistStatics(WithScene, WrappedComponent);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./withScene.jsx\n **/"],"sourceRoot":""}