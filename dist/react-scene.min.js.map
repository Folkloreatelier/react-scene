{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-scene.min.js","webpack:///webpack/bootstrap e24393a1c66fc45dadf5","webpack:///./index.js","webpack:///./ReactScene.jsx","webpack:///./createReactScene.js","webpack:///external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack:///./createScene.jsx","webpack:///../~/hoist-non-react-statics/index.js","webpack:///./withScene.jsx"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","ReactScene","createReactScene","createScene","withScene","METHODS","createSceneMethod","method","args","i","al","arguments","length","push","callSceneMethod","DEFAULT_METHODS","methodPascal","reactScene","propTypes","width","React","PropTypes","number","height","onRemote","func","childContextTypes","scene","object","contextTypes","getChildContext","parent","context","ml","getDefaultProps","loadOnMount","buildOnLoad","playOnBuild","destroyOnUnmount","getInitialState","calling","render","props","children","componentDidMount","remote","createRemote","load","setTimeout","componentWillUnmount","destroy","componentDidUpdate","prevProps","prevState","onRemoteChanged","resize","sizeChanged","name","state","setState","pascalName","substr","toUpperCase","methodName","willLoadName","didLoadName","done","bind","isAsync","obj","async","methodArgs","concat","methodReturn","apply","then","promiseDone","sceneDidLoad","build","sceneDidBuild","play","replace","g0","g1","g2","toLowerCase","bool","createClass","displayName","getDisplayName","WrappedComponent","_extends","Object","assign","target","source","key","prototype","hasOwnProperty","hoistStatics","SceneComponent","SceneWithContext","cloneElement","screenWrapper","methodProps","createRefMethod","createElement","ref","refMethod","refs","console","warn","SceneWrapper","REACT_STATICS","defaultProps","mixins","type","KNOWN_STATICS","caller","arity","isGetOwnPropertySymbolsAvailable","getOwnPropertySymbols","targetComponent","sourceComponent","customStatics","keys","getOwnPropertyNames","error","WithScene"],"mappings":"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","file":"react-scene.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScene\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactScene\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactScene\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactScene\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar ReactScene = __webpack_require__(1);\n\tReactScene.createReactScene = __webpack_require__(2);\n\tReactScene.createScene = __webpack_require__(4);\n\tReactScene.withScene = __webpack_require__(6);\n\t\n\tmodule.exports = ReactScene;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar createReactScene = __webpack_require__(2);\n\t\n\tmodule.exports = createReactScene();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(3);\n\t\n\tvar DEFAULT_METHODS = ['load', 'build', 'resize', 'mute', 'unmute', 'play', 'pause', 'end', 'destroy'];\n\t\n\tfunction createReactScene(METHODS) {\n\t    if (typeof METHODS === 'undefined') {\n\t        METHODS = DEFAULT_METHODS;\n\t    }\n\t\n\t    var reactScene = {\n\t\n\t        propTypes: {\n\t\n\t            width: React.PropTypes.number,\n\t            height: React.PropTypes.number,\n\t\n\t            // loadOnMount: React.PropTypes.bool,\n\t            // buildOnLoad: React.PropTypes.bool,\n\t            // playOnBuild: React.PropTypes.bool,\n\t\n\t            onRemote: React.PropTypes.func\n\t\n\t        },\n\t\n\t        childContextTypes: {\n\t            scene: React.PropTypes.object\n\t        },\n\t\n\t        contextTypes: {\n\t            scene: React.PropTypes.object\n\t        },\n\t\n\t        getChildContext: function getChildContext() {\n\t            var scene = {\n\t                parent: this.context.scene || null\n\t            };\n\t\n\t            var method;\n\t            for (var i = 0, ml = METHODS.length; i < ml; i++) {\n\t                method = METHODS[i];\n\t                scene[method] = this[method];\n\t            }\n\t\n\t            return {\n\t                scene: scene\n\t            };\n\t        },\n\t\n\t        getDefaultProps: function getDefaultProps() {\n\t            return {\n\t                width: 0,\n\t                height: 0,\n\t\n\t                loadOnMount: true,\n\t                buildOnLoad: false,\n\t                playOnBuild: false,\n\t                destroyOnUnmount: true\n\t            };\n\t        },\n\t\n\t        getInitialState: function getInitialState() {\n\t            return {\n\t                calling: null\n\t            };\n\t        },\n\t\n\t        render: function render() {\n\t            return this.props.children || null;\n\t        },\n\t\n\t        componentDidMount: function componentDidMount() {\n\t            if (this.props.onRemote) {\n\t                var remote = this.createRemote();\n\t                this.props.onRemote(remote);\n\t            }\n\t\n\t            if (this.load && this.props.loadOnMount) {\n\t                var load = this.load;\n\t                setTimeout(function () {\n\t                    load();\n\t                }, 1);\n\t            }\n\t        },\n\t\n\t        componentWillUnmount: function componentWillUnmount() {\n\t            if (this.destroy && this.props.destroyOnUnmount) {\n\t                this.destroy();\n\t            }\n\t        },\n\t\n\t        componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t            var onRemoteChanged = prevProps.onRemote !== this.props.onRemote;\n\t            if (onRemoteChanged && this.props.onRemote) {\n\t                var remote = this.createRemote();\n\t                this.props.onRemote(remote);\n\t            }\n\t\n\t            if (this.resize) {\n\t                var sizeChanged = prevProps.width !== this.props.width || prevProps.height !== this.props.height;\n\t                if (sizeChanged) {\n\t                    this.resize();\n\t                }\n\t            }\n\t        },\n\t\n\t        callSceneMethod: function callSceneMethod(name, args) {\n\t            if (this.state.calling === name) {\n\t                return;\n\t            }\n\t\n\t            this.setState({\n\t                calling: name\n\t            });\n\t\n\t            var pascalName = name.substr(0, 1).toUpperCase() + name.substr(1);\n\t            var methodName = name;\n\t            var willLoadName = 'sceneWill' + pascalName;\n\t            var didLoadName = 'sceneDid' + pascalName;\n\t\n\t            var done = function () {\n\t                this.setState({\n\t                    calling: null\n\t                });\n\t\n\t                //Call the \"did\" lifecycle method\n\t                if (this.props[didLoadName]) {\n\t                    this.props[didLoadName]();\n\t                }\n\t\n\t                if (this[didLoadName]) {\n\t                    this[didLoadName]();\n\t                }\n\t            }.bind(this);\n\t\n\t            var isAsync = false;\n\t            var obj = {\n\t                async: function async() {\n\t                    isAsync = true;\n\t                    return done;\n\t                }\n\t            };\n\t\n\t            //Calling \"will\" lifecycle method\n\t            if (this.props[willLoadName]) {\n\t                this.props[willLoadName]();\n\t            }\n\t\n\t            //Calling method\n\t            if (this.props[methodName]) {\n\t                var methodArgs = [obj].concat(args);\n\t                var methodReturn = this.props[methodName].apply(null, methodArgs);\n\t                if (methodReturn && methodReturn.then) {\n\t                    var promiseDone = obj.async();\n\t                    methodReturn.then(promiseDone);\n\t                }\n\t            }\n\t\n\t            //If the call is not async, it's done\n\t            if (!isAsync) {\n\t                done();\n\t            }\n\t        },\n\t\n\t        createRemote: function createRemote() {\n\t            var remote = {};\n\t            var method;\n\t            for (var i = 0, ml = METHODS.length; i < ml; i++) {\n\t                method = METHODS[i];\n\t                remote[method] = this[method];\n\t            }\n\t\n\t            return remote;\n\t        },\n\t\n\t        /**\n\t         * Scene lifecycle\n\t         */\n\t        sceneDidLoad: function sceneDidLoad() {\n\t            if (this.build && this.props.buildOnLoad) {\n\t                this.build();\n\t            }\n\t        },\n\t\n\t        sceneDidBuild: function sceneDidBuild() {\n\t            if (this.play && this.props.playOnBuild) {\n\t                this.play();\n\t            }\n\t        }\n\t\n\t    };\n\t\n\t    function createSceneMethod(method) {\n\t        return function () {\n\t            var args = [];\n\t            for (var i = 0, al = arguments.length; i < al; i++) {\n\t                args.push(arguments[i]);\n\t            }\n\t            this.callSceneMethod(method, args);\n\t        };\n\t    }\n\t\n\t    var method, methodPascal;\n\t    for (var i = 0, ml = METHODS.length; i < ml; i++) {\n\t        method = METHODS[i];\n\t        methodPascal = method.replace(/(\\w)(\\w*)/g, function (g0, g1, g2) {\n\t            return g1.toUpperCase() + g2.toLowerCase();\n\t        });\n\t\n\t        //PropTypes\n\t        reactScene.propTypes[method] = React.PropTypes.func;\n\t        reactScene.propTypes['sceneWill' + methodPascal] = React.PropTypes.func;\n\t        reactScene.propTypes['sceneDid' + methodPascal] = React.PropTypes.func;\n\t        if (method === 'destroy') {\n\t            reactScene.propTypes.destroyOnUnmount = React.PropTypes.bool;\n\t        } else if (method === 'build') {\n\t            reactScene.propTypes.buildOnLoad = React.PropTypes.bool;\n\t        } else if (method === 'load') {\n\t            reactScene.propTypes.loadOnMount = React.PropTypes.bool;\n\t        }\n\t\n\t        // Methods\n\t        reactScene[method] = createSceneMethod(method);\n\t    }\n\t\n\t    var ReactScene = React.createClass(reactScene);\n\t    ReactScene.displayName = 'ReactScene';\n\t\n\t    return ReactScene;\n\t}\n\t\n\tcreateReactScene.DEFAULT_METHODS = DEFAULT_METHODS;\n\t\n\tmodule.exports = createReactScene;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar React = __webpack_require__(3);\n\tvar createReactScene = __webpack_require__(2);\n\tvar hoistStatics = __webpack_require__(5);\n\t\n\tfunction getDisplayName(WrappedComponent) {\n\t    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\t}\n\t\n\tmodule.exports = function (SceneComponent, props, METHODS) {\n\t    if (typeof METHODS === 'undefined') {\n\t        METHODS = createReactScene.DEFAULT_METHODS;\n\t    }\n\t\n\t    var ReactScene = createReactScene(METHODS);\n\t\n\t    //Passes context as props\n\t    var SceneWithContext = function SceneWithContext(props, context) {\n\t        var children = React.cloneElement(props.children, {\n\t            scene: context.scene\n\t        });\n\t\n\t        return children;\n\t    };\n\t\n\t    SceneWithContext.contextTypes = {\n\t        scene: React.PropTypes.object\n\t    };\n\t\n\t    //Scene wrapper\n\t    var screenWrapper = {\n\t\n\t        render: function render() {\n\t            var methodProps = {};\n\t            var method;\n\t            for (var i = 0, ml = METHODS.length; i < ml; i++) {\n\t                method = METHODS[i];\n\t                methodProps[method] = this.createRefMethod('component', method);\n\t            }\n\t\n\t            /* jshint ignore:start */\n\t            return React.createElement(\n\t                ReactScene,\n\t                _extends({\n\t                    ref: 'scene'\n\t                }, props, this.props, methodProps),\n\t                React.createElement(\n\t                    SceneWithContext,\n\t                    null,\n\t                    React.createElement(SceneComponent, _extends({ ref: 'component' }, this.props))\n\t                )\n\t            );\n\t            /* jshint ignore:end */\n\t        },\n\t\n\t        createRefMethod: function createRefMethod(ref, method) {\n\t            var refMethod = function refMethod() {\n\t                if (this.refs[ref] && this.refs[ref][method]) {\n\t                    this.refs[ref][method].apply(null, arguments);\n\t                } else {\n\t                    console.warn('Method \"' + method + '\" not implemented on component ' + getDisplayName(SceneComponent));\n\t                }\n\t            };\n\t\n\t            if (this) {\n\t                refMethod = refMethod.bind(this);\n\t            }\n\t\n\t            return refMethod;\n\t        }\n\t\n\t    };\n\t\n\t    //Add methods to wrapper\n\t    var method;\n\t    for (var i = 0, ml = METHODS.length; i < ml; i++) {\n\t        method = METHODS[i];\n\t        screenWrapper[method] = screenWrapper.createRefMethod.call(null, 'scene', method);\n\t    }\n\t\n\t    var SceneWrapper = React.createClass(screenWrapper);\n\t    SceneWrapper.displayName = 'scene(' + getDisplayName(SceneComponent) + ')';\n\t    SceneWrapper.SceneComponent = SceneComponent;\n\t\n\t    return hoistStatics(SceneWrapper, SceneComponent);\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t    name: true,\n\t    length: true,\n\t    prototype: true,\n\t    caller: true,\n\t    arguments: true,\n\t    arity: true\n\t};\n\t\n\tvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\t\n\tmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t        var keys = Object.getOwnPropertyNames(sourceComponent);\n\t\n\t        /* istanbul ignore else */\n\t        if (isGetOwnPropertySymbolsAvailable) {\n\t            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n\t                try {\n\t                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n\t                } catch (error) {\n\t\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return targetComponent;\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar ReactScene = __webpack_require__(1);\n\tvar hoistStatics = __webpack_require__(5);\n\t\n\tfunction getDisplayName(WrappedComponent) {\n\t    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\t}\n\t\n\tmodule.exports = function (WrappedComponent) {\n\t    var WithScene = React.createClass({\n\t        displayName: 'WithScene',\n\t\n\t\n\t        contextTypes: {\n\t            scene: React.PropTypes.object\n\t        },\n\t\n\t        render: function render() {\n\t            /* jshint ignore:start */\n\t            return React.createElement(WrappedComponent, _extends({}, this.props, { scene: this.context.scene }));\n\t            /* jshint ignore:end */\n\t        }\n\t\n\t    });\n\t\n\t    WithScene.displayName = 'withScene(' + getDisplayName(WrappedComponent) + ')';\n\t    WithScene.WrappedComponent = WrappedComponent;\n\t\n\t    return hoistStatics(WithScene, WrappedComponent);\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-scene.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e24393a1c66fc45dadf5\n **/","var ReactScene = require('./ReactScene');\nReactScene.createReactScene = require('./createReactScene');\nReactScene.createScene = require('./createScene');\nReactScene.withScene = require('./withScene');\n\nmodule.exports = ReactScene;\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","\nvar createReactScene = require('./createReactScene');\n\nmodule.exports = createReactScene();\n\n\n\n/** WEBPACK FOOTER **\n ** ./ReactScene.jsx\n **/","var React = require('react');\n\nvar DEFAULT_METHODS = [\n    'load',\n    'build',\n    'resize',\n    'mute',\n    'unmute',\n    'play',\n    'pause',\n    'end',\n    'destroy'\n];\n\nfunction createReactScene(METHODS)\n{\n    if(typeof(METHODS) === 'undefined')\n    {\n        METHODS = DEFAULT_METHODS;\n    }\n    \n    var reactScene = {\n        \n        propTypes: {\n            \n            width: React.PropTypes.number,\n            height: React.PropTypes.number,\n            \n            // loadOnMount: React.PropTypes.bool,\n            // buildOnLoad: React.PropTypes.bool,\n            // playOnBuild: React.PropTypes.bool,\n            \n            onRemote: React.PropTypes.func\n            \n        },\n        \n        childContextTypes: {\n            scene: React.PropTypes.object\n        },\n        \n        contextTypes: {\n            scene: React.PropTypes.object\n        },\n        \n        getChildContext: function()\n        {\n            var scene = {\n                parent: this.context.scene || null\n            };\n            \n            var method;\n            for(var i = 0, ml = METHODS.length; i < ml; i++)\n            {\n                method = METHODS[i];\n                scene[method] = this[method];\n            }\n            \n            return {\n                scene: scene\n            };\n        },\n        \n        getDefaultProps: function()\n        {\n            return {\n                width: 0,\n                height: 0,\n                \n                loadOnMount: true,\n                buildOnLoad: false,\n                playOnBuild: false,\n                destroyOnUnmount: true\n            };\n        },\n        \n        getInitialState: function()\n        {\n            return {\n                calling: null\n            };\n        },\n        \n        render: function()\n        {\n            return this.props.children || null;\n        },\n        \n        componentDidMount: function()\n        {\n            if(this.props.onRemote)\n            {\n                var remote = this.createRemote();\n                this.props.onRemote(remote);\n            }\n            \n            if(this.load && this.props.loadOnMount)\n            {\n                var load = this.load;\n                setTimeout(function()\n                {\n                    load();\n                }, 1);\n            }\n        },\n        \n        componentWillUnmount: function()\n        {\n            if(this.destroy && this.props.destroyOnUnmount)\n            {\n                this.destroy();\n            }\n        },\n        \n        componentDidUpdate: function(prevProps, prevState)\n        {\n            var onRemoteChanged = prevProps.onRemote !== this.props.onRemote;\n            if(onRemoteChanged && this.props.onRemote)\n            {\n                var remote = this.createRemote();\n                this.props.onRemote(remote);\n            }\n            \n            if(this.resize)\n            {\n                var sizeChanged = prevProps.width !== this.props.width || prevProps.height !== this.props.height;\n                if(sizeChanged)\n                {\n                    this.resize();\n                }\n            }\n        },\n        \n        callSceneMethod: function(name, args)\n        {\n            if(this.state.calling === name)\n            {\n                return;\n            }\n            \n            this.setState({\n                calling: name\n            });\n            \n            var pascalName = name.substr(0, 1).toUpperCase()+name.substr(1);\n            var methodName = name;\n            var willLoadName = 'sceneWill'+pascalName;\n            var didLoadName = 'sceneDid'+pascalName;\n            \n            var done = function()\n            {\n                this.setState({\n                    calling: null\n                });\n                \n                //Call the \"did\" lifecycle method\n                if(this.props[didLoadName])\n                {\n                    this.props[didLoadName]();\n                }\n                \n                if(this[didLoadName])\n                {\n                    this[didLoadName]();\n                }\n                \n            }.bind(this);\n            \n            var isAsync = false;\n            var obj = {\n                async: function()\n                {\n                    isAsync = true;\n                    return done;\n                }\n            };\n            \n            //Calling \"will\" lifecycle method\n            if(this.props[willLoadName])\n            {\n                this.props[willLoadName]();\n            }\n            \n            //Calling method\n            if(this.props[methodName])\n            {\n                var methodArgs = [obj].concat(args);\n                var methodReturn = this.props[methodName].apply(null, methodArgs);\n                if(methodReturn && methodReturn.then)\n                {\n                    var promiseDone = obj.async();\n                    methodReturn.then(promiseDone);\n                }\n            }\n            \n            //If the call is not async, it's done\n            if(!isAsync)\n            {\n                done();\n            }\n        },\n        \n        createRemote: function()\n        {\n            var remote = {};\n            var method;\n            for(var i = 0, ml = METHODS.length; i < ml; i++)\n            {\n                method = METHODS[i];\n                remote[method] = this[method];\n            }\n            \n            return remote;\n        },\n        \n        /**\n         * Scene lifecycle\n         */\n        sceneDidLoad: function()\n        {\n            if(this.build && this.props.buildOnLoad)\n            {\n                this.build();\n            }\n        },\n        \n        sceneDidBuild: function()\n        {\n            if(this.play && this.props.playOnBuild)\n            {\n                this.play();\n            }\n        }\n        \n    };\n    \n    function createSceneMethod(method)\n    {\n        return function()\n        {\n            var args = [];\n            for(var i = 0, al = arguments.length; i < al; i++)\n            {\n                args.push(arguments[i]);\n            }\n            this.callSceneMethod(method, args);\n        };\n    }\n    \n    var method, methodPascal;\n    for(var i = 0, ml = METHODS.length; i < ml; i++)\n    {\n        method = METHODS[i];\n        methodPascal = method.replace(/(\\w)(\\w*)/g, function(g0,g1,g2)\n        {\n            return g1.toUpperCase() + g2.toLowerCase();\n        });\n        \n        //PropTypes\n        reactScene.propTypes[method] = React.PropTypes.func;\n        reactScene.propTypes['sceneWill'+methodPascal] = React.PropTypes.func;\n        reactScene.propTypes['sceneDid'+methodPascal] = React.PropTypes.func;\n        if(method === 'destroy')\n        {\n            reactScene.propTypes.destroyOnUnmount = React.PropTypes.bool;\n        }\n        else if(method === 'build')\n        {\n            reactScene.propTypes.buildOnLoad = React.PropTypes.bool;\n        }\n        else if(method === 'load')\n        {\n            reactScene.propTypes.loadOnMount = React.PropTypes.bool;\n        }\n        \n        // Methods\n        reactScene[method] = createSceneMethod(method);\n    }\n    \n    var ReactScene = React.createClass(reactScene);\n    ReactScene.displayName = 'ReactScene';\n    \n    return ReactScene;\n}\n\ncreateReactScene.DEFAULT_METHODS = DEFAULT_METHODS;\n\nmodule.exports = createReactScene;\n\n\n\n/** WEBPACK FOOTER **\n ** ./createReactScene.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}\n ** module id = 3\n ** module chunks = 0\n **/","var React = require('react');\nvar createReactScene = require('./createReactScene');\nvar hoistStatics = require('hoist-non-react-statics');\n\nfunction getDisplayName(WrappedComponent)\n{\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nmodule.exports = function(SceneComponent, props, METHODS)\n{\n    if(typeof(METHODS) === 'undefined')\n    {\n        METHODS = createReactScene.DEFAULT_METHODS;\n    }\n    \n    var ReactScene = createReactScene(METHODS);\n    \n    //Passes context as props\n    var SceneWithContext = function(props, context)\n    {\n        var children = React.cloneElement(props.children, {\n            scene: context.scene\n        });\n        \n        return children;\n    };\n    \n    SceneWithContext.contextTypes = {\n        scene: React.PropTypes.object\n    };\n    \n    //Scene wrapper\n    var screenWrapper = {\n        \n        render: function()\n        {\n            var methodProps = {};\n            var method;\n            for(var i = 0, ml = METHODS.length; i < ml; i++)\n            {\n                method = METHODS[i];\n                methodProps[method] = this.createRefMethod('component', method);\n            }\n            \n            /* jshint ignore:start */\n            return (\n                <ReactScene\n                    ref=\"scene\"\n                    {...props}\n                    {...this.props}\n                    {...methodProps}\n                    >\n                    <SceneWithContext>\n                        <SceneComponent ref=\"component\" {...this.props} />\n                    </SceneWithContext>\n                </ReactScene>\n            );\n            /* jshint ignore:end */\n        },\n        \n        createRefMethod: function(ref, method)\n        {\n            var refMethod = function()\n            {\n                if(this.refs[ref] && this.refs[ref][method])\n                {\n                    this.refs[ref][method].apply(null, arguments);\n                }\n                else\n                {\n                    console.warn('Method \"'+method+'\" not implemented on component '+getDisplayName(SceneComponent));\n                }\n            };\n            \n            if(this)\n            {\n                refMethod = refMethod.bind(this);\n            }\n            \n            return refMethod;\n        }\n        \n    };\n    \n    //Add methods to wrapper\n    var method;\n    for(var i = 0, ml = METHODS.length; i < ml; i++)\n    {\n        method = METHODS[i];\n        screenWrapper[method] = screenWrapper.createRefMethod.call(null, 'scene', method);\n    }\n    \n    var SceneWrapper = React.createClass(screenWrapper);\n    SceneWrapper.displayName = `scene(${getDisplayName(SceneComponent)})`;\n    SceneWrapper.SceneComponent = SceneComponent;\n    \n    return hoistStatics(SceneWrapper, SceneComponent);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./createScene.jsx\n **/","/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nmodule.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/hoist-non-react-statics/index.js\n ** module id = 5\n ** module chunks = 0\n **/","var ReactScene = require('./ReactScene');\nvar hoistStatics = require('hoist-non-react-statics');\n\nfunction getDisplayName(WrappedComponent)\n{\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nmodule.exports = function(WrappedComponent)\n{\n    var WithScene = React.createClass({\n        \n        contextTypes: {\n            scene: React.PropTypes.object\n        },\n        \n        render: function()\n        {\n            /* jshint ignore:start */\n            return (\n                <WrappedComponent {...this.props} scene={this.context.scene} />\n            );\n            /* jshint ignore:end */\n        }\n        \n    });\n    \n    WithScene.displayName = `withScene(${getDisplayName(WrappedComponent)})`;\n    WithScene.WrappedComponent = WrappedComponent;\n    \n    return hoistStatics(WithScene, WrappedComponent);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./withScene.jsx\n **/"],"sourceRoot":""}